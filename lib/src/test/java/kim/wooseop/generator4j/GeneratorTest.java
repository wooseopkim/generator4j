/*
 * This source file was generated by the Gradle 'init' task
 */
package kim.wooseop.generator4j;

import static org.junit.jupiter.api.Assertions.*;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import org.junit.jupiter.api.Test;

public class GeneratorTest {

    @Test
    public void stream_empty() {
        try (var generator = new Generator<Void>((ignored) -> {})) {

            var list = generator.stream().toList();

            assertEquals(Collections.emptyList(), list);
        } catch (Exception e) {
            fail(e);
        }
    }

    @Test
    public void iterable_singleElement() {
        try (var generator = new Generator<String>((ctx) -> ctx.yield("Java"))) {

            var list = new ArrayList<String>();
            for (var val : generator) {
                list.add(val);
            }

            assertEquals(Collections.singletonList("Java"), list);
        } catch (Exception e) {
            fail(e);
        }
    }

    @Test
    public void stream_singleElement() {
        try (var generator = new Generator<>((ctx) -> ctx.yield("Java"))) {

            var list = generator.stream().toList();

            assertEquals(Collections.singletonList("Java"), list);
        } catch (Exception e) {
            fail(e);
        }
    }

    @Test
    public void stream_multipleElements() {
        try (var generator = new Generator<>((ctx) -> {
            ctx.yield("Honestly");
            ctx.yield("I");
            ctx.yield("have");
            ctx.yield("no");
            ctx.yield("idea");
            ctx.yield("what");
            ctx.yield("I'm");
            ctx.yield("doing");
        })) {

            var list = generator.stream().toList();

            assertEquals(List.of("Honestly", "I", "have", "no", "idea", "what", "I'm", "doing"), list);
        } catch (Exception e) {
            fail(e);
        }
    }

    @Test
    public void stream_infinite() {
        try (var generator = new Generator<Integer>((ctx) -> {
            while (true) {
                ctx.yield(42);
            }
        })) {
            var size = 10_000;

            var list = generator.stream().limit(size).toList();

            assertEquals(size, list.size());
            assertTrue(list.stream().allMatch(x -> x == 42));
        } catch (Exception e) {
            fail(e);
        }
    }

    @Test
    public void iterable_infinite() {
        try (var generator = new Generator<Integer>((ctx) -> {
            while (true) {
                ctx.yield(42);
            }
        })) {
            var counter = 0;

            for (var value : generator) {
                if (++counter >= 10_000) {
                    break;
                }

                assertEquals(42, value);
            }
        } catch (Exception e) {
            fail(e);
        }
    }

    @Test
    public void finish_withoutValue() {
        try (var generator = new Generator<Integer>((ctx) -> {
            ctx.yield(1);
            ctx.yield(3);
            ctx.yield(5);
            ctx.finish();
            ctx.yield(7);
            ctx.yield(9);
        })) {

            var list = generator.stream().toList();

            assertEquals(List.of(1, 3, 5), list);
        } catch (Exception e) {
            fail(e);
        }
    }

    @Test
    public void finish_withValue() {
        try (var generator = new Generator<Integer>((ctx) -> {
            for (var i = 0; i < 5; i++) {
                if (i == 3) {
                    ctx.finish(-1);
                }
                ctx.yield(i);
            }
            ctx.yield(9);
        })) {

            var list = generator.stream().toList();

            assertEquals(List.of(0, 1, 2, -1), list);
        } catch (Exception e) {
            fail(e);
        }
    }

    @Test
    public void close() throws Exception {
        var threadReference = new AtomicReference<Thread>();
        Function<Runnable, Thread> threadProvider = (runnable) -> {
            var thread = new Thread(runnable);
            threadReference.set(thread);
            return thread;
        };
        var generator = new Generator<Integer>(threadProvider, (ctx) -> ctx.yield(1));
        generator.iterator().hasNext();
        var thread = threadReference.get();

        assertNotEquals(Thread.State.TERMINATED, thread.getState());
        generator.close();

        assertEquals(Thread.State.TERMINATED, thread.getState());
    }

    @Test
    public void stream_noExecutionBeforeRequested() {
        var executed = new AtomicBoolean(false);
        try (var generator = new Generator<String>((ctx) -> executed.set(true))) {

            assertFalse(executed.get());
            generator.iterator().hasNext();

            assertTrue(executed.get());
        } catch (Exception e) {
            fail(e);
        }
    }
}
